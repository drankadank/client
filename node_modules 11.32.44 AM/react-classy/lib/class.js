/**
 *
 * Classy - Class Helpers
 *
 * @module lib/class
 * @description
 *   Helpers for modifying and getting values from Classy ReactComponents
 */

'use strict';

var _extends = require('babel-runtime/helpers/extends')['default'];

var _Object$getOwnPropertyDescriptor = require('babel-runtime/core-js/object/get-own-property-descriptor')['default'];

var _Object$defineProperty = require('babel-runtime/core-js/object/define-property')['default'];

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

var _interopRequireWildcard = require('babel-runtime/helpers/interop-require-wildcard')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.redefineLifecycleMethods = redefineLifecycleMethods;
exports.redefineRender = redefineRender;
exports.redefineComponentWillMount = redefineComponentWillMount;
exports.redefineComponentWillUnmount = redefineComponentWillUnmount;
exports.getComponentCSS = getComponentCSS;

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _state = require('./state');

var State = _interopRequireWildcard(_state);

var _dom = require('./dom');

var DOM = _interopRequireWildcard(_dom);

/**
 *
 * Redefines component lifecycle methods for auto style un/mounting
 *
 * @param {*} args - Arugments passed by callee
 */

function redefineLifecycleMethods() {
  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  [redefineRender, redefineComponentWillMount, redefineComponentWillUnmount].forEach(function (fn) {
    return fn.apply(undefined, args);
  });
}

/**
 *
 * If Component styles have loaded,
 * Component.prototype.render(...) will curry the original method
 * Otherwise, `null` will be returned to avoid FOUC
 *
 * @param {ReactComponent} Component - React component to be unstyled
 * @param {String}         alias     - Component alias
 */

function redefineRender(Component, alias) {
  var method = 'render';
  var fn = Component.prototype[method];

  // Component is NOT a class
  if (fn && typeof fn !== 'function') throw new TypeError('Classy Error: redefineRender(...)\n' + 'Expected componentWillMount(...) to be a function.\n' + ('-> Got type ' + typeof fn));
  // Update prop descriptor
  var descriptor = _Object$getOwnPropertyDescriptor(Component.prototype, method);
  _Object$defineProperty(Component.prototype, method, _extends({}, descriptor, {
    // With new value
    value: function render() {
      var state = State.getComponentState(alias);
      var isStyled = state.isStyled;

      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      return isStyled ? _react2['default'].createElement(
        'span',
        null,
        fn.call.apply(fn, [this].concat(args))
      ) : _react2['default'].createElement(
        'span',
        { style: { display: 'none' } },
        fn.call.apply(fn, [this].concat(args))
      );
    }
  }));
}

/**
 *
 * Caches component instances and attempts to update styles
 * if component class styles have yet to be loaded
 *
 * @param {ReactComponent} Component - React component to be unstyled
 * @param {String}         alias     - Component alias
 */

function redefineComponentWillMount(Component, alias) {
  var method = 'componentWillMount';
  var fn = Component.prototype[method];

  // Component is NOT a class
  if (fn && typeof fn !== 'function') throw new TypeError('Classy Error: redefineComponentWillMount(...)\n' + 'Expected componentWillMount(...) to be a function.\n' + ('-> Got type ' + typeof fn));
  // Update prop descriptor
  var descriptor = _Object$getOwnPropertyDescriptor(Component.prototype, method);
  _Object$defineProperty(Component.prototype, method, _extends({}, descriptor, {
    // With new value
    value: function componentWillMount() {
      var _this = this;

      // Cache instance
      var numMounted = State.cacheComponentInstance(alias, this);
      // Update styles
      var state = State.getComponentState(alias);
      var instances = state.instances;
      var loadingStyles = state.loadingStyles;
      var isStyled = state.isStyled;
      var debug = state.debug;
      var settings = state.settings;

      // Update styles
      if (!isStyled && !loadingStyles) (function callee$2$0() {
        return _regeneratorRuntime.async(function callee$2$0$(context$3$0) {
          while (1) switch (context$3$0.prev = context$3$0.next) {
            case 0:
              context$3$0.prev = 0;
              context$3$0.next = 3;
              return _regeneratorRuntime.awrap(DOM.updateStyle(alias));

            case 3:
              context$3$0.next = 8;
              break;

            case 5:
              context$3$0.prev = 5;
              context$3$0.t0 = context$3$0['catch'](0);

              console.warn(context$3$0.t0);

            case 8:
            case 'end':
              return context$3$0.stop();
          }
        }, null, _this, [[0, 5]]);
      })();
      // Call original method

      for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }

      if (fn) return fn.call.apply(fn, [this].concat(args));
    }
  }));
}

/**
 *
 * Removes cached component instance and, if no other instances are mounted,
 * removes component class styles as well
 *
 * @param {ReactComponent} Component - React component to be unstyled
 * @param {String}         alias     - Component alias
 */

function redefineComponentWillUnmount(Component, alias) {
  var method = 'componentWillUnmount';
  var fn = Component.prototype[method];

  // Component is NOT a class
  if (fn && typeof fn !== 'function') throw new TypeError('Classy Error: redefineComponentWillUnmount(...)\n' + 'Expected componentWillUnmount(...) to be a function.\n' + ('-> Got type ' + typeof fn));
  // Update prop descriptor
  var descriptor = _Object$getOwnPropertyDescriptor(Component.prototype, method);
  _Object$defineProperty(Component.prototype, method, _extends({}, descriptor, {
    // With new value
    value: function componentWillUnmount() {
      var _this2 = this;

      // Clear instance from cache
      var numMounted = State.clearComponentInstance(alias, this);
      // Remove styles
      var state = State.getComponentState(alias);
      var isStyled = state.isStyled;
      var debug = state.debug;
      var settings = state.settings;
      var hot = settings.hot;

      // Remove styles
      if (isStyled && numMounted < 1) (function callee$2$0() {
        return _regeneratorRuntime.async(function callee$2$0$(context$3$0) {
          while (1) switch (context$3$0.prev = context$3$0.next) {
            case 0:
              context$3$0.prev = 0;
              context$3$0.next = 3;
              return _regeneratorRuntime.awrap(DOM.removeStyle(alias));

            case 3:
              context$3$0.next = 8;
              break;

            case 5:
              context$3$0.prev = 5;
              context$3$0.t0 = context$3$0['catch'](0);

              console.warn(context$3$0.t0);

            case 8:
            case 'end':
              return context$3$0.stop();
          }
        }, null, _this2, [[0, 5]]);
      })();
      // Call original method

      for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }

      if (fn) return fn.call.apply(fn, [this].concat(args));
    }
  }));
}

/**
 *
 * Gets a component's cssText
 *
 * @param  {String}  alias - Component alias
 * @return {Promise}       - Promise to fulfill component cssText
 */

function getComponentCSS(alias) {
  var state, Component, currentTheme, previousTheme, cssText, settings, styleProp, themeProp, debug, hot, style, themes, theme, returnValue;
  return _regeneratorRuntime.async(function getComponentCSS$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        state = State.getComponentState(alias);
        Component = state.Component;
        currentTheme = state.currentTheme;
        previousTheme = state.previousTheme;
        cssText = state.cssText;
        settings = state.settings;
        styleProp = settings.styleProp;
        themeProp = settings.themeProp;
        debug = settings.debug;
        hot = settings.hot;
        style = Component[styleProp];
        themes = Component[themeProp];
        theme = themes ? themes[currentTheme] : undefined;
        returnValue = undefined;

        if (!(!hot && cssText && currentTheme !== previousTheme)) {
          context$1$0.next = 16;
          break;
        }

        return context$1$0.abrupt('return', cssText);

      case 16:
        if (!(typeof style === 'string')) {
          context$1$0.next = 20;
          break;
        }

        returnValue = style;
        context$1$0.next = 27;
        break;

      case 20:
        if (!(typeof style === 'function')) {
          context$1$0.next = 26;
          break;
        }

        context$1$0.next = 23;
        return _regeneratorRuntime.awrap(style(theme));

      case 23:
        returnValue = context$1$0.sent;
        context$1$0.next = 27;
        break;

      case 26:
        throw new TypeError('Classy Error: getComponentCSS(...)\n' + ('Expected component ' + alias + '\'s styleProp to be a string or Promise ') + 'that fulfills with a string.\n' + ('-> Got type \'' + typeof style + '\'.'));

      case 27:
        return context$1$0.abrupt('return', returnValue);

      case 28:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

// Merge old descriptor

// Merge old descriptor

// Merge old descriptor

// Use cached cssText

// style is a string

// style returns a Promise

// TypeError: style is NOT a string or Promise